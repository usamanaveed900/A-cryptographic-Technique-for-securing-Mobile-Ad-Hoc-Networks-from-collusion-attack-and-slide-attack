# A Cryptographic Technique For Securing Mobile Ad-Hoc Networks From Collusion Attack and Slide Attack
This is a proposed encryption and decryption process:
## Encryption Side
`Step 1:` First take 8-bit plaintext ‘Pt’,

`Step 2:` Convert each character/letter into its ASCII value,

`Step 3:` Convert ASCII values into binary value V,

`Step 4:` take 8-bit key value K generated by ElGamal cryptosystem,

`Step 5:` Apply S-Box substitution on output of step 3 , the output will be in 4-bits,

`Step 6:` Apply S-Box substitution on K, the output will be in 4-bits,

`Step 7:` Combine the outputs of step 3 and 4, it will be in the form of 8-bit value,

`Step 8:` Now compute DNA digital coding scheme on the receiving 8-bit output of step 5,

`Step 9:` The output of the step 6 will be the Cipher Text.

`Step 10:` End procedure.


## Decryption Side
`Step 1:` Compute DNA Digital coding scheme in reverse, the output will be as 8-bit value,

`Step 2:` Divide the 8-bit value, that is the output of the step 1, the output will be in two half’s, each will be in 4-bit value,

`Step 3:` Take the output of step 2 as input and refer V to the first half of 4-bit and K to the second half

`Step 4:` Compute the S-Box substitution in reverse on both of the values and extract the 8-bit values from  S-Box row and column respectively,

`Step 5:` Then first 8-bits are taken as V,

`Step 6:` Convert binary value of V into ASCII,

`Step 7:` Then convert ASCII values into Characters/letters,

`Step 8:` Output of step 7 will be decrypted test.

`Step 9:` Stop procedure.

###  ElGamal Key generation Algorithm
The Algorithm works as follows:
We have public keys (P, g, y)
- 1 private key X 
- We have to choose the values of p, g and x randomly by the user but we have to find out the value of key Y
- For computation of Y the formula is:
```Y = 𝑔^𝑥  𝑚𝑜𝑑  𝑝```
- The value of Y is our key value.

#### Snippet
```
        public static int gcd(int a, int b)
        {
            if (a < b)
            {
                return gcd(b, a);
            }
            else if (a % b == 0)
            {
                return b;
            }
            else
            {
                return gcd(b, a % b);
            }
        }

        public static int genKey(int q)
        {
            Random rand1 = new Random();
            string b = Convert.ToString(Math.Pow(10, 2));
            int key = int.Parse(Convert.ToString(rand1.Next(int.Parse(b), q)));

            while (gcd(q, key) != 1)
            {
                b = Convert.ToString(Math.Pow(10, 2));
                key = int.Parse(Convert.ToString(rand1.Next(int.Parse(b), q)));
            }
            return key;
        }

```

### DNA Digital Coding Algorithm

- First take 8 bit input into binary form ```e.g. 01101101```
- Divide them into pairs, each pair consist of two bits
 ```e.g. Input bits = 01101101```
 ```Pairs = 01 10 11 01```
- Then give each pair a value according to its digital sequence:

| Binary Value  | DNA Digital Sequene |
| ------------- | ------------- |
| 00  | A  |
| 01  | C  |
| 10  | G  |
| 11  | T  |

- Now convert paired bits into DNA digital sequence to make Cipher Text:
 ```e.g. Paired bits = 01 10 11 01```
 ```Cipher Text = C G T C``` 
- End encryption process.

#### Snippet
```
        public static string DNAdigitalCoding(string binary)
        {
            string DNAdigitalSequence=null;
            if (binary == "00")
                DNAdigitalSequence = "A";
            else if (binary == "01")
                DNAdigitalSequence = "C";
            else if (binary == "10")
                DNAdigitalSequence = "G";
            else if (binary == "11")
                DNAdigitalSequence = "T";
            else
                MessageBox.Show("INVALID BINARY!!");
            return DNAdigitalSequence;

        }
```



### S-Box
```
        public static string S_box(string temp)
        {
            string[,] Box = new string[17, 17] 
            { {"" ,"1000", "1001", "1010", "1011","1100","1101","1110","1111","0000","0001","0010","0011","0100","0101","0110","0111" },
              {"0000" ,"A1", "B3", "0A", "C2","D3","DS","E3","J4","CM","O2","PP","LO","IR","HQ","MZ","QH" },
              {"0001" ,"Q1", "B2", "D5", "0B","D2","8B","Q4","QS","K4","HR","P2","AR","DO","JS","RI","HO" },
              {"0010" ,"AB", "RJ", "C3", "E6","OC","E2","PB","F3","TO","L4","CO","Q2","ZM","SJ","UR","QY" },
              {"0011","BC", "ZA", "SK", "D4","F7","0D","F2","NP","G3","MD","M4","KI","TK","VE","EV","RU" },
              {"0100" ,"DE", "XB", "JL", "TL","E5","G8","OE","G2","GM","H3","DP","UL","7B","R2","3T","OY" },
              {"0101" ,"FG", "YC", "KI", "E4","UM","F6","H9","OF","H2","MV","VM","5E","N4","6C","S2","LO" },
              {"0110" ,"HI", "WD", "L2", "F4","9V","VN","G7","IA","0G","WN","I2","I3","7Z","O4","YO","T2" },
              {"0111" ,"JK", "UE", "M3", "7O","G4","8X","WO","H8","XO","0H","N3","J2","J3","5N","P4","CV" },
              {"1000" ,"LM", "SF", "N4", "4L","6B","H4","XP","YP","I9","JB","0I","O3","K2","K3","4W","Q4" },
              {"1001" ,"NO", "QG", "O5", "4A","ST","3D","ZQ","YQ","OT","JA","KC","0J","P3","L2","L3","TV" },
              {"1010" ,"PQ", "OH", "P6", "I4","QE","IR","0U","V3","ZR","OS","KB","LD","0K","Q3","M2","MP" },
              {"1011" ,"RS", "MI", "Q7", "2M","2S","OV","U2","W3","X3","IS","OR","LC","ME","0L","S3","N2" },
              {"1100" ,"TU", "KJ", "R8", "GT","0W","U4","FP","V2","Y3","Z3","2T","OQ","ON","NF","0M","R3" },
              {"1101" ,"VW", "IK", "4U", "0X","T4","WZ","LT","PT","W2","XA","PO","3U","OP","NE","OG","0N" },
              {"1110" ,"XY", "5V", "0Y", "S4","ZB","YX","V4","W4","BS","X2","Y4","T3","4V","0O","FT","PH" },
              {"1111" ,"6W", "0Z", "R4", "9L","Z4","ZW","MS","RP","9C","CS","Y2","U3","Z2","5W","6X","PG" }
            };
            string first = temp.Substring(0, 4);
            string second = temp.Substring(4, 4);
            int firstIndex = 0;
            int secondIndex = 0;
            for (int i = 1; i < 17;i++ )
            {
                if(Box[i,0]==first)
                {
                    firstIndex = i;
                }
            }
            for (int j = 1; j < 17;j++ )
            {
                if(Box[0,j]==second)
                {
                    secondIndex = j;
                }
            }
            return (temp = Box[firstIndex, secondIndex].ToString());
        }
```

### Result Parameters
- GICT `(Generating Intermediate Cipher text Time)`
- KGT `(Key Generation Time)`
- GET `(Generating full encryption time)`
- Response Time GDT `(Generating decryption time)`

### Video Explain

### Authors

* **Usama Naveed** -https://github.com/usamanaveed900)
* **Instagram** -https://www.instagram.com/naveedusama/
* **Youtube** -https://www.youtube.com/channel/UCB3IljOaBGkrmbuBzC8ziBQ

See also the list of [Projects] (https://github.com/usamanaveed900?tab=repositories) I have woked on.


